{"version":3,"sources":["Plot/LineSegment.tsx","Plot/PlotAxes.tsx","Plot/PlotView.tsx","utils/mapNumber.ts","Plot/LineSegmentData.ts","sweepLine.ts","Plot/PlotState.ts","Plot/InputTable.tsx","App.tsx","index.tsx","Plot/Plot.module.css"],"names":["observer","data","state","x0","xToPx","x","y0","yToPx","y","x1","y1","dragHandler","useRef","action","index","newX","newY","pxToX","pxToY","current","dragHandler0","_","lastX","lastY","dragHandler1","defaultPosition","position","onDrag","onStop","className","styles","lineSegmentPoint","within","plot","horizontal","bounds","minX","maxX","vertical","minY","maxY","borderColor","zIndex","useState","shouldRender","setShouldRender","useEffect","setTimeout","drag","deltaX","deltaY","cancel","segments","map","seg","i","num","inMin","inMax","outMin","outMax","Type","s","PlotState","width","height","makeObservable","this","offsetX","scale","offsetY","pop","point","push","dX","dY","cross","px","observable","computed","SegmentRow","segment","type","value","Number","toFixed","onChange","e","isNaN","target","valueAsNumber","CrossRow","dot","Array","GetY","id","Math","min","Cross","id1","id2","n","x2","y2","x3","y3","x4","y4","q","sn","max","SweepLine","length","ListA","ListB","xMin","xMax","Start","Finish","sort","a","b","j","splice","SearchCrossUp","SearchCrossDown","indDown","findIndex","element","delIndex","ind","t","IndexCross","addCross","alert","onClick","addSegment","deleteSegment","ReactDOM","render","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.4a72b179.chunk.js","sourcesContent":["import { action } from 'mobx'\nimport { observer } from 'mobx-react-lite'\nimport { useRef } from 'react'\nimport Draggable, { DraggableData } from 'react-draggable'\nimport { Line } from 'react-lineto'\nimport {LineSegmentData} from './LineSegmentData'\nimport styles from './Plot.module.css'\nimport PlotState from './PlotState'\n\ntype Props = {\n    data: LineSegmentData\n    state: PlotState\n}\n\n// отрисовка отрезка\nconst LineSegment = ({ data, state }: Props) => {\n    const x0 = state.xToPx(data[0].x)\n    const y0 = state.yToPx(data[0].y)\n    const x1 = state.xToPx(data[1].x)\n    const y1 = state.yToPx(data[1].y)\n\n    const dragHandler = useRef(\n        action((index: 0 | 1, newX: number, newY: number) => {\n            data[index].x = state.pxToX(newX)\n            data[index].y = state.pxToY(newY)\n        })\n    ).current\n\n    const dragHandler0 = useRef((_: unknown, data: DraggableData) =>\n        dragHandler(0, data.lastX, data.lastY)\n    ).current\n    const dragHandler1 = useRef((_: unknown, data: DraggableData) =>\n        dragHandler(1, data.lastX, data.lastY)\n    ).current\n\n    // первые два draggable - перетаскиваемые точки\n    // line - линия между ними\n    return (\n        <>\n            <Draggable\n                defaultPosition={{ x: x0, y: y0 }}\n                position={{ x: x0, y: y0 }}\n                onDrag={dragHandler0}\n                onStop={dragHandler0}\n            >\n                <div className={styles.lineSegmentPoint} />\n            </Draggable>\n            <Draggable\n                defaultPosition={{ x: x1, y: y1 }}\n                position={{ x: x1, y: y1 }}\n                onDrag={dragHandler1}\n                onStop={dragHandler1}\n            >\n                <div className={styles.lineSegmentPoint} />\n            </Draggable>\n            <Line x0={x0} y0={y0} x1={x1} y1={y1} within={styles.plot} />\n        </>\n    )\n}\n\nexport default observer(LineSegment)\n","import { observer } from 'mobx-react-lite'\nimport PlotState from './PlotState'\nimport { Line } from 'react-lineto'\nimport styles from './Plot.module.css'\ntype Props = {\n    state: PlotState\n}\n\n// линии на x=0 и y=0\nconst PlotAxes = ({ state }: Props) => {\n    const horizontal = {\n        x0: state.xToPx(state.bounds.minX),\n        x1: state.xToPx(state.bounds.maxX),\n        y0: state.yToPx(0),\n        y1: state.yToPx(0),\n    }\n    const vertical = {\n        x0: state.xToPx(0),\n        x1: state.xToPx(0),\n        y0: state.yToPx(state.bounds.minY),\n        y1: state.yToPx(state.bounds.maxY),\n    }\n\n    return (\n        <>\n            <Line\n                x0={horizontal.x0}\n                x1={horizontal.x1}\n                y0={horizontal.y0}\n                y1={horizontal.y1}\n                borderColor=\"gray\"\n                zIndex={-1}\n                within={styles.plot}\n            />\n            <Line\n                x0={vertical.x0}\n                x1={vertical.x1}\n                y0={vertical.y0}\n                y1={vertical.y1}\n                borderColor=\"gray\"\n                zIndex={-1}\n                within={styles.plot}\n            />\n        </>\n    )\n}\n\nexport default observer(PlotAxes)\n","import { observer } from 'mobx-react-lite'\nimport { useEffect, useRef, useState } from 'react'\nimport PlotState from './PlotState'\nimport styles from './Plot.module.css'\nimport LineSegment from './LineSegment'\nimport PlotAxes from './PlotAxes'\nimport { DraggableCore, DraggableData } from 'react-draggable'\n\ntype Props = {\n    state: PlotState\n}\n\n// сам график\nconst PlotView = ({ state }: Props) => {\n    const [shouldRender, setShouldRender] = useState(false)\n    useEffect(() => {\n        setTimeout(() => setShouldRender(true), 100)\n    })\n\n    const dragHandler = useRef((_: unknown, data: DraggableData) =>\n        state.drag(data.deltaX, data.deltaY)\n    ).current\n\n    return (\n        <DraggableCore\n            onDrag={dragHandler}\n            cancel={'.' + styles.lineSegmentPoint}\n        >\n            <div className={styles.plot}>\n                {shouldRender && (\n                    <>\n                        {state.segments.map((seg, i) => (\n                            <LineSegment data={seg} state={state} key={i} />\n                        ))}\n                        <PlotAxes state={state} />\n                    </>\n                )}\n            </div>\n        </DraggableCore>\n    )\n}\n\nexport default observer(PlotView)\n","export function map(\n    num: number,\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number\n): number {\n    return ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin\n}\n","type Point = { x: number; y: number } // тип точки\n\nexport enum Type {\n    Start,\n    Cross,\n    Finish\n}\n\nexport type LineSegmentData = [Point, Point] // тип отрезка\nexport type CrossPoint = [Point]\nexport type ListEvent = {x: number, type: Type, id: number, id2?: number}\n\n\n","import {LineSegmentData, ListEvent, Type} from './Plot/LineSegmentData'\n\nimport PlotState from './Plot/PlotState'\n\n\nlet s : LineSegmentData[]\nconst dot: number[] = new Array(2)  // точка пересечения\n\nfunction SweepLine(state: PlotState) {\n    s = state.segments\n    state.cross.length = 0\n    const ListA: ListEvent[] = new Array(2*s.length); //список целей по x\n    const ListB: number[] = []\n    \n    for (let i = 0; i < s.length; i++){\n        let xMin: number, xMax : number\n        const x1 = s[i][0].x;\n        const x2 = s[i][1].x;\n        if (x1 == x2){\n            const y1 = s[i][0].y;\n            const y2 = s[i][1].y;\n            [xMin, xMax] = y1<y2? [x1,x2]:[x2,x1];\n        } else {\n            [xMin, xMax] = [Math.min(x1,x2),Math.max(x1,x2)];\n        }\n        ListA[2*i] = {x: xMin,type: Type.Start,id: i}\n        ListA[2*i+1] = {x: xMax,type: Type.Finish,id: i}\n    }\n    ListA.sort(function(a, b) {\n        return a.x - b.x\n    });\n\n    for (let i = 0; i < ListA.length; i++){\n        if (ListA[i].type == Type.Start){ //начало отрезка\n            let j\n            for (j=0; j < ListB.length; j++){\n                if (GetY(ListB[j],ListA[i].x) > GetY(ListA[i].id,ListA[i].x))\n                    break\n            }\n            ListB.splice(j,0,ListA[i].id)\n            SearchCrossUp(j) //поиск перечечения сверху\n            SearchCrossDown(j) //поиск перечечения снизу\n        } else if (ListA[i].type == Type.Cross) { //пересечение\n            const indDown = ListB.findIndex(element => element == ListA[i].id); //index нижнего отрезка в момент пересечения\n            [ListB[indDown], ListB[indDown+1]] = [ListB[indDown+1], ListB[indDown]]\n            SearchCrossUp(indDown+1)\n            SearchCrossDown(indDown)   \n        } else { //конец отрезка\n            const delIndex = ListB.findIndex(element => element == ListA[i].id)\n            ListB.splice(delIndex,1)\n\n        }\n        /*alert(\"ListA\")\n        ListA.forEach(function (s) {\n            alert(s.x)\n            alert(s.type)\n        });\n        alert(\"ListB\")\n        ListB.forEach(function (s) {\n            alert(s)\n        });*/\n    }\n    alert(\"Количество найденных пересечений: \"+state.cross.length)\n\n    /*ListA.forEach(function (s) {\n        alert(s.x)\n    });*/\n\n    function SearchCrossUp(ind: number) {     \n        if (ind+1 < ListB.length ? Cross(ListB[ind],ListB[ind+1]): false) {\n            \n            const t = IndexCross(dot[0])\n            if (t != -1) { //если текущего пересечения ещё нет в списке ListA\n                ListA.splice(t,0,{x: dot[0],type: Type.Cross,id: ListB[ind], id2: ListB[ind+1]})\n                state.addCross([{x: dot[0],y: dot[1]}])\n            }\n        }\n    }\n\n    function SearchCrossDown(ind: number) {\n        if (ind-1 >= 0 ? Cross(ListB[ind],ListB[ind-1]): false) {\n            \n            const t = IndexCross(dot[0])\n            if (t != -1) { //если текущего пересечения ещё нет в списке ListA\n                ListA.splice(t,0,{x: dot[0],type: Type.Cross,id: ListB[ind-1], id2: ListB[ind]})\n                state.addCross([{x: dot[0],y: dot[1]}])  \n            }   \n        }\n    }\n\n    function IndexCross(x: number) {\n        let ind\n        for (ind=0; ind < ListA.length; ind++){\n            //if (ListA[ind] == {x: dot[0],type: Type.Cross,id: ListB[ind-1], id2: ListB[ind]})\n            if (ListA[ind].x == dot[0] && ListA[ind].type == Type.Cross)\n                return -1\n            if (ListA[ind].x >= x)\n                break\n        }\n        return ind\n    }\n}\n\n\n\n\n\nfunction GetY(id: number, x: number) { //возвращает координату y, зная id отрезка и x координату\n    if (s[id][0].x == s[id][1].x)\n        return (Math.min(s[id][0].y, s[id][1].y))\n    return s[id][0].y + (s[id][1].y - s[id][0].y) * (x - s[id][0].x) / (s[id][1].x - s[id][0].x)\n}\n\n\nfunction Cross(id1: number, id2: number): boolean {\n    const [x1,y1,x2,y2] = [s[id1][0].x,s[id1][0].y,s[id1][1].x,s[id1][1].y]\n    const [x3,y3,x4,y4] = [s[id2][0].x,s[id2][0].y,s[id2][1].x,s[id2][1].y]\n    let n: number;\n    if (y2 - y1 != 0) {  // a(y)\n        const q = (x2 - x1) / (y1 - y2)   \n        const sn = (x3 - x4) + (y3 - y4) * q; if (!sn) return false  // c(x) + c(y)*q\n        const fn = (x3 - x1) + (y3 - y1) * q   // b(x) + b(y)*q\n        n = fn / sn\n    }\n    else {\n        if (!(y3 - y4)) return false  // b(y)\n        n = (y3 - y1) / (y3 - y4)   // c(y)/b(y)\n    }\n    dot[0] = x3 + (x4 - x3) * n // x3 + (-b(x))*n\n    dot[1] = y3 + (y4 - y3) * n  // y3 +(-b(y))*n\n    return (dot[0] >= Math.min(x1,x2) && dot[0] <= Math.max(x1,x2) && dot[0] >= Math.min(x3,x4) && dot[0] <= Math.max(x3,x4))? true:false\n}\n\nexport default SweepLine","import { action, computed, makeObservable, observable } from 'mobx'\nimport { map } from '../utils/mapNumber'\nimport {LineSegmentData, CrossPoint} from './LineSegmentData'\n\ntype Bounds = {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n}\n\nexport default class PlotState {\n    @observable offsetX = 0 // смещение по X и Y (для перетаскивания графика)\n    @observable offsetY = 0\n    @observable scale = 0.1 // масшиаб\n\n    // cписок отрезков\n    @observable segments: LineSegmentData[] = [\n        [\n            { x: 0, y: 0 },\n            { x: 2, y: 2 },\n        ],\n    ]\n\n    @observable cross: CrossPoint[] = []\n\n    constructor(readonly width: number, readonly height: number) {\n        makeObservable(this)\n    }\n\n    // границы отображения графика на экране\n    @computed get bounds(): Bounds {\n        return {\n            minX: this.offsetX - (this.width / 2) * this.scale,\n            minY: this.offsetY - (this.height / 2) * this.scale,\n            maxX: this.offsetX + (this.width / 2) * this.scale,\n            maxY: this.offsetY + (this.height / 2) * this.scale,\n        }\n    }\n\n    // удалить последний отрезок\n    @action deleteSegment() {\n        this.segments.pop()\n    }\n\n    // добавить отрезок\n    @action addSegment(point: LineSegmentData) {\n        this.segments.push(point)\n    }\n\n    // перетаскивание графика мышкой\n    @action drag(dX: number, dY: number) {\n        this.offsetX -= dX * this.scale;\n        this.offsetY += dY * this.scale;\n    }\n\n    @action addCross(point: CrossPoint) {\n        this.cross.push(point)\n    }\n\n    pxToY(px: number) {\n        return map(px, 0, this.height, this.bounds.maxY, this.bounds.minY)\n    }\n\n    pxToX(px: number) {\n        return map(px, 0, this.width, this.bounds.minX, this.bounds.maxX)\n    }\n\n    yToPx(y: number) {\n        return map(y, this.bounds.minY, this.bounds.maxY, this.height, 0)\n    }\n\n    xToPx(x: number) {\n        return map(x, this.bounds.minX, this.bounds.maxX, 0, this.width)\n    }\n}\n","import { action } from 'mobx'\nimport { observer } from 'mobx-react-lite'\nimport {LineSegmentData, CrossPoint} from './LineSegmentData'\nimport PlotState from './PlotState'\n\n\ntype TableProps = {\n    state: PlotState\n}\n\ntype RowProps = { segment: LineSegmentData }\ntype RowCross = { cross: CrossPoint }\n\nconst SegmentRow = observer(({ segment }: RowProps) => (\n    <tr>\n        <td>\n            <input\n                type={'number'}\n                value={Number(segment[0].x.toFixed(4))}\n                onChange={action(e => (!isNaN(e.target.valueAsNumber) && (segment[0].x = e.target.valueAsNumber)))}\n            />\n        </td>\n        <td>\n            <input\n                type={'number'}\n                value={Number(segment[0].y.toFixed(4))}\n                onChange={action(e => (!isNaN(e.target.valueAsNumber) && (segment[0].y = e.target.valueAsNumber)))}\n            />\n        </td>\n        <td>\n            <input\n                type={'number'}\n                value={Number(segment[1].x.toFixed(4))}\n                onChange={action(e => (!isNaN(e.target.valueAsNumber) && (segment[1].x = e.target.valueAsNumber)))}\n            />\n        </td>\n        <td>\n            <input\n                type={'number'}\n                value={Number(segment[1].y.toFixed(4))}\n                onChange={action(e => (!isNaN(e.target.valueAsNumber) && (segment[1].y = e.target.valueAsNumber)))}\n            />\n        </td>\n    </tr>\n))\n\nconst CrossRow = observer(({ cross }: RowCross) => (\n    <tr>\n        <td>\n            <input\n                type={'number'}\n                value={Number(cross[0].x.toFixed(4))}\n                onChange={action(e => (!isNaN(e.target.valueAsNumber) && (cross[0].x = e.target.valueAsNumber)))}\n            />\n        </td>\n        <td>\n            <input\n                type={'number'}\n                value={Number(cross[0].y.toFixed(4))}\n                onChange={action(e => (!isNaN(e.target.valueAsNumber) && (cross[0].y = e.target.valueAsNumber)))}\n            />\n        </td>\n    </tr>\n))\n\n// таблица для ввода данных\nconst InputTable = ({ state }: TableProps) => (\n    <div>\n    <table>\n        <thead>\n            <tr>\n                <td>x0</td>\n                <td>y0</td>\n                <td>x1</td>\n                <td>y1</td>\n            </tr>\n            </thead>\n        <tbody>\n            {state.segments.map((seg, i) => (\n                <SegmentRow key={i} segment={seg} />\n            ))}\n        </tbody>\n    </table>\n    <table>\n    <thead>\n        <tr>\n            <td>x</td>\n            <td>y</td>\n        </tr>\n        </thead>\n        <tbody>\n            {state.cross.map((seg, i) => (\n                <CrossRow key={i} cross={seg} />\n            ))}\n        </tbody>\n    </table>\n    </div>\n    \n)\n\nexport default observer(InputTable)\n","import React from 'react'\nimport PlotView from './Plot/PlotView'\nimport PlotState from './Plot/PlotState'\nimport { observer } from 'mobx-react-lite'\nimport InputTable from './Plot/InputTable'\nimport SweepLine from './sweepLine'\n//import { allowStateReadsStart } from 'mobx/dist/internal'\n\nconst state = new PlotState(500, 500)\n\nfunction App() {  \n    return <div className=\"App\">\n        <PlotView state={state} />\n        <button onClick={() => state.addSegment([{ x: -2, y: 2 }, { x: 2, y: 2 }])}>Добавить</button>\n        <button onClick={() => state.deleteSegment()}>Удалить</button>\n        <button onClick={() => SweepLine(state)}>Начать</button>\n        <InputTable state={state} />\n    </div>\n}\n\nexport default observer(App)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"plot\":\"Plot_plot__3YHXA\",\"lineSegmentPoint\":\"Plot_lineSegmentPoint__r3rJt\"};"],"sourceRoot":""}